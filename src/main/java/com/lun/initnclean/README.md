# Initialization & Cleanup #

## Cleanup:finalization and garbage collection ##

Java有回收器负责回收无用对象占据的内存资源。

但也有**特殊情况**：假定你的对象（**并非使用new**）获得一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new 分配的内存，所以它不知道该如何释放该对象的这块“特殊”内存。

为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。（finalize()用于特定方法）

它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占有的存储空间，将首先调用其finalize()方法，并且在下一次**垃圾回收动作发生之时**，才会真正回收对象占用的内存。所以要是你打算用finalize(),就能垃圾回收时刻做一些重要的清理工作。

本地方法 是 一种在Java 中调用非Java代码（C++或C）的方式。

free()函数是C和C++中的函数，所以需要在finalize()中用本地方法调用它。

---

Java中

1. 对象可能不被垃圾回收
2. 垃圾回收并不等于“析构”（C++中的概念）
3. 垃圾回收只与内存有关

Java并未提供“析构函数”或相似的概念，要做类似的清理工作，必须自己动手创建一个执行清理工作的普通方法。

例如，假设某个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦除，它可能永远得不到清理。

如果finalize()里加入某种擦除功能，当“垃圾回收”发生时（不能保证一定会发生），finalize()得到了调用，图像就会被擦除。要是“垃圾回收”没有发生，图像就会一直不留下来

---

**通常，不能指望finalize()，必须创建其他的“清理”方法，并且明确地调用它们**。

finalize()只能存在于程序员很难用到的一些晦涩用法里。

不过，finalize可用在 对象**终结条件**的验证

当对某个对象不再感兴趣——也就是它可以被清理了，这对象应该处于某种状态，使它占用的内存可以被安全地释放。

例如，要是对象代表了一个打开的文件，在对象被回收前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的缺陷。

finalize()可以用来最终发现这种情况——尽管它并不总是会被调用。如果某些finalize()的动作使得缺陷被发现，那么就可据此找出问题所在——这才是人们真正关心的。（相信这里起到安全网的作用）

[TerminationCondition](TerminationCondition.java)

---

下面来自Effective Java 2nd

>终结方法finalize通常是不可预测的，也是很危险，一般情况是不必要的。

>终结方法有两种合法用途：

>1. 当对象的所有者忘记调用前面段落中建议的显式终止方法时，终结方法可以充当“安全网（safety net）”

>2. 跟对象的本地对等体（native peer）有关。本地对等体是个本体对象（native object），普通对象通过本地方法（native method）委托给一个本地对象。它是一种特殊的对象，垃圾回收器不会知道它，所以终结方法是一种最合适的回收工具。
